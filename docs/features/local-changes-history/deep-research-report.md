# Аналитический отчёт о функции Local Changes History для TUI IDE

## Контекст и целевое назначение функции

В предоставленных концепт‑файлах описана функция **Local Changes History / Local Changes Panel**: в терминальном редакторе появляется панель, которая показывает все изменённые файлы и их diff, с быстрым «восстановлением» файла к исходному состоянию и возможностью отменить восстановление (undo restore). fileciteturn0file0

Ключевой мотив сформулирован как реакция на практику использования AI‑агентов (Claude Code, Cursor, Aider, Codex), которые способны менять много файлов вне фокуса пользователя; редактор должен дать «птичий обзор» изменений и быстрый, безопасный rollback «по одному файлу» и «по всем». fileciteturn0file0 fileciteturn0file1

С точки зрения индустриальных референсов, задуманное ближе всего к git‑панелям современных редакторов, где есть (а) список изменённых файлов, (б) предпросмотр диффов, (в) действия discard/restore, (г) (опционально) стадирование/unstage по файлам и по чанкам. Документация и публичные материалы **Zed** описывают «Project Diff» (мультибуфер диффов всего проекта) и keyboard‑driven staging/restore; это полезный ориентир для UX‑деталей и производственных рисков (например: зависания на огромных множествах untracked). citeturn12search1turn12search5turn12search8

Далее отчёт разбирает: что в концепции уже хорошо, чего не хватает для корректной работы с baseline/статусами/правами, и как это лучше реализовать в TUI‑IDE в духе Vim/Helix.

## Анализ текущей концепции и выявленные пробелы

Концепция задаёт два режима:

- **Project Mode**: корень проекта = CWD; если есть Git, baseline = `git HEAD`, список изменений = `git status`, diff = `git diff HEAD`, restore = «вернуть к HEAD». fileciteturn0file0 fileciteturn0file1  
- **Single File Mode**: для «одиночных» файлов (например `sudo qedit /etc/hosts`) baseline = snapshot при открытии, хранение в `~/.local/state/...`, панель показывает только этот файл, при sudo home определяется по `$SUDO_USER` через lookup. fileciteturn0file0 fileciteturn0file1

Это хорошая «скелетная» рамка, но в реальной эксплуатации TUI‑редакторов и Git‑репозиториев есть систематические пробелы.

### Семантика baseline в Git: только HEAD недостаточно

В Git есть как минимум **три “дерева” состояния**: `HEAD` (последний коммит), `index` (staging area) и `working tree` (рабочая директория). citeturn11search3turn11search2  
Отсюда следует, что «изменения» бывают **двух типов одновременно**: staged и unstaged; и один и тот же файл может иметь и то и другое. Это же отмечают пользователи Zed как источник UX‑путаницы, если интерфейс не различает эти компоненты. citeturn12search0turn11search3

Текущая формула «baseline=HEAD; diff=git diff HEAD; restore=git checkout HEAD -- file» не задаёт явного ответа на вопросы:

- Показываем ли мы **unstaged diff** (working tree vs index) или **суммарный diff** (working tree vs HEAD) или оба слоя отдельно? citeturn11search0turn11search3  
- Что значит “Restore” для файла, если часть изменений уже в индексе? В Git есть разные операции: восстановить working tree из index (discard unstaged), либо восстановить и index и working tree из HEAD (discard staged+unstaged). Это различие прямо зафиксировано в документации `git restore` (источник по умолчанию зависит от флагов `--staged/--worktree`). citeturn1search1turn11search12turn11search25

Итог: **без явного моделирования staged/unstaged** панель либо будет «технически правильной, но неожиданной», либо будет уничтожать данные (например, сбрасывать staged без предупреждения).

### Untracked/ignored, удаления, переименования, конфликты

В Git‑мире «изменённые файлы» — это не только `Modified`:

- `Added` (новый, tracked после add), `Untracked` (ещё не tracked), `Deleted`, `Renamed/Copied`, `Unmerged` (конфликты). Эти состояния экспонируются `git status`, причём для парсинга скриптами рекомендуется `--porcelain`, а v2 добавляет более строгий/расширяемый формат. citeturn3search1turn3search5turn3search10  
- У Git есть rename detection на уровне diff; это важный нюанс, иначе UI будет показывать rename как delete+add, что ухудшает обзор изменения. citeturn3search26turn12search18  
- В состоянии merge/rebase конфликты требуют особой семантики restore (например, «взять ours/theirs»), и `git restore` имеет отдельные опции для unmerged путей (`--ours/--theirs/--merge`). citeturn1search1

В текущей концепции эти статусы перечислены частично в типах, но не раскрыты в правилах baseline/restore/UX (особенно untracked и unmerged). fileciteturn0file1

### «Проект = CWD» против «Git‑root»: конфликт ожиданий

Концепция утверждает «проект = текущая папка (CWD)». fileciteturn0file0  
Но Git‑операции часто естественно привязаны к **корню репозитория**, а porcelain‑вывод `git status` всегда возвращает пути **относительно repo root** (и игнорирует `status.relativePaths`), что удобно для парсинга, но может расширить область видимости за пределы CWD. citeturn3search5turn3search1

Если пользователь запускает редактор из подкаталога монорепо, он может ожидать «изменения только в этой части», а git‑панель покажет «всё в репозитории». В Zed подобные вопросы тоже всплывают как UX‑аспект выбора repo/workspace. citeturn12search12  
Это надо проектно решить (и лучше — сделать управляемым настройкой/переключателем).

### Вне Git: «lazy snapshot только для открытых файлов» не покрывает основной AI‑use case

В non‑git режиме предлагается «baseline = snapshot при первом открытии файла; отслеживаем только открытые файлы — экономит место и время». fileciteturn0file0 fileciteturn0file1

Это разумно для «классического редактора», но **слабое место именно для заявленного сценария AI‑агентов**: агент может изменить 10 файлов, которые пользователь не открывал — панель изменений их не увидит по определению (нет baseline). Концепция частично упоминает fsnotify/сканирование, но без решения проблемы baseline для «неоткрытых» файлов. fileciteturn0file1

Практический вывод: для non‑git проекта придётся выбрать один из двух компромиссов:

- либо вводить **baseline уровня проекта** (скан/манифест при старте/по требованию),  
- либо честно фиксировать, что non‑git режим даёт «изменения только по файлам, которые редактор наблюдает/индексирует», и тогда UI/документация должны это явно показывать.

### Суперправа: определение home при sudo — только половина задачи

Идея «не писать state в /root, а писать в home реального пользователя через `$SUDO_USER` и lookup» полезна. fileciteturn0file0 fileciteturn0file1  
Но если сам процесс редактора запущен как root, он создаст файлы в state‑директории **с владельцем root**, что затем может привести к проблемам чтения/очистки у обычного пользователя. Здесь критично использовать не только имя пользователя, но и `SUDO_UID/SUDO_GID` (они выставляются sudo), и выставлять владельца/права на создаваемые артефакты. citeturn6view0

Более фундаментально: `sudo`‑документация прямо предупреждает о риске shell‑escape и о том, что «большинство редакторов» дают возможность «эффективной root‑шелл‑сессии». citeturn6view0  
То есть лучшая практика — **не запускать весь редактор как root**, а поднимать привилегии точечно (подход sudoedit). Ниже это разобрано отдельно.

## Базовые состояния файлов и определение baseline в разных контекстах

### Что такое baseline в терминах функции

Для панели «Local Changes» baseline — это «точка отсчёта», относительно которой:

1) вычисляется diff;  
2) определяется «изменённость»;  
3) выполняется restore/revert.

Критично, чтобы baseline был **однозначным и объяснимым пользователю**, иначе restore станет неожиданным и опасным действием (особенно при staged/unstaged и при sudo). citeturn11search3turn1search1

### Git: baseline как многослойная конструкция (HEAD + index)

Git документирует, что `git diff` может показывать различия между рабочим каталогом и индексом, индексом и деревом коммита и т.д. citeturn11search0  
На практике для интерфейса «изменения перед коммитом» лучше считать baseline **двухуровневым**:

- **Baseline A (для staged):** `HEAD` → `index` (то, что пойдёт в следующий коммит)  
- **Baseline B (для unstaged):** `index` → `working tree` (то, что ещё не staged)

Эту ментальную модель поддерживает Pro Git («три дерева») и она нужна, чтобы корректно отразить состояние файла и дать предсказуемые действия «discard unstaged» vs «discard all». citeturn11search3turn11search2

У `git restore` это различие материализовано в поведении по умолчанию: если `--staged` не указан, содержимое восстанавливается из **index**, а если указан `--staged`, то источник по умолчанию — **HEAD**. citeturn1search1turn11search12

Отсюда UX‑рекомендация: даже если вы не реализуете полноценное staging, **панель должна уметь различать** «в файле есть staged изменения» и «есть unstaged изменения» (и оба сразу) и явно показывать, что именно будет восстановлено выбранной командой.

### Non‑git: baseline как «сессия» или «зафиксированный снимок»

Вне Git baseline можно определить несколькими способами:

- **Snapshot при первом открытии файла** (как в концепции). Плюс: дешёво и локально. Минус: не охватывает файлы, которые изменились «вне поля зрения» редактора. fileciteturn0file0  
- **Snapshot на момент открытия проекта** (манифест всех файлов + быстрые метаданные). Плюс: покрывает AI‑агента, изменившего «неоткрытые» файлы. Минус: дорого на больших деревьях, требует ignore‑политики.  
- **Явный baseline‑checkpoint** (команда «Set Baseline» / «Reset Baseline») — особенно важен в non‑git, где нет естественной «точки истины». Это снижает сюрпризы, потому что пользователь контролирует «эпоху изменений».

Так как концепция уже выбирает `~/.local/state/...` как место хранения snapshot‑данных, стоит привязать это к **XDG Base Directory Specification**, где `$XDG_STATE_HOME` предназначен именно для долговременных «state files» (сессии, история, layout и т.п.), с дефолтом `$HOME/.local/state`. citeturn2search3turn2search11

### Сравнение подходов к baseline

Ниже — сравнительная таблица подходов, с акцентом на то, как они ведут себя в «AI меняет много файлов» и в режимах sudo/permissions. citeturn11search3turn1search1turn2search3

| Подход baseline | Что считается baseline | Детекция изменений | Восстановление | Сильные стороны | Типовые риски |
|---|---|---|---|---|---|
| Git‑HEAD | Содержимое файла в `HEAD` | `git status` + diff | restore к `HEAD` | Естественная «истина» для tracked файлов; быстро для больших проектов (делегируем Git) | Не различает staged/unstaged без доп. модели; untracked не покрывается напрямую |
| Git‑index+worktree (двухслойно) | `HEAD→index` и `index→worktree` | `git status --porcelain=v2` + `git diff` по слоям | отдельные действия discard unstaged / discard all | UX предсказуем; корректная семантика для partially staged | Сложнее UI и модель состояний; нужно тщательно подписывать действия |
| Snapshot «при первом открытии» | Содержимое файла в момент первого открытия редактором | сравнение с snapshot | восстановить snapshot | Дёшево, просто, подходит «на файл» | Не видит изменения в неоткрытых файлах; baseline устаревает между сессиями без политики «сброса эпохи» |
| Snapshot «на момент открытия проекта» | Снимок/хэши всех файлов проекта | fsnotify +/или скан | восстановить по манифесту | Лучшее покрытие non‑git проектов, включая изменения AI | Требует ignore‑политики, контроля размера, оптимизации IO |
| Встроенная «локальная VCS» (CAS/ревизии) | Контент‑адресуемое хранилище версий | журналирование записей | откат к выбранной ревизии | Даёт настоящую «историю», не только baseline | Сильно усложняет продукт; требует GC/квот/конфиденциальности |

## Архитектура реализации: детекция изменений, diff, хранение и производительность

### Git‑интеграция: стабильный парсинг и слой безопасности

**Парсинг статуса.** Для надёжной машины‑интерпретации Git рекомендует porcelain‑формат `git status --porcelain`; документация подчёркивает его стабильность и пригодность для скриптов. citeturn3search5turn3search1  
Формат v2 добавляет расширяемые заголовки и больше полей состояния (удобно для UI), что прямо описано в `git-status`. citeturn3search1turn3search10  
Для корректной обработки «странных» имён файлов и разделителей хорошей практикой является использование `-z` (NUL‑terminate), чтобы не зависеть от экранирования/переносов строк. citeturn3search1

**Генерация diff.** `git diff` документирован как механизм сравнения «рабочий каталог ↔ индекс ↔ дерево коммита», что позволяет вам строить двухуровневый diff без изобретения велосипеда. citeturn11search0  
Для производительности стоит вычислять diff **по требованию** (для выбранного файла или видимого диапазона), а не строить единый гигантский дифф на весь репозиторий.

**Safe.directory и root.** Важно учесть, что современный Git по умолчанию отказывается работать с репозиториями «чужого владельца» (защита от CVE‑2022‑24765); это отражено и в документации Git, и в практических разборках. citeturn2search21turn1search5  
Следствие для вашего дизайна: если редактор запускается под `sudo` в пользовательском репозитории, git‑операции могут упасть с «dubious ownership». Лучшее решение — **не выполнять Git‑команды от root** (см. раздел про sudoedit‑подход).

### Non‑git: наблюдение файловой системы — только гибрид

Концепция предлагает «fsnotify или периодический скан». fileciteturn0file1  
На практике один лишь fsnotify редко даёт стопроцентную надёжность на всех ОС и масштабах:

- **Linux/inotify**: наблюдение директорий не рекурсивно — для поддеревьев требуется ставить watch на каждую поддиректорию, что может быть дорого на больших деревьях. citeturn7search0  
  Лимиты описываются через `/proc/sys/fs/inotify/max_user_watches` и родственные параметры. citeturn7search12  
  Индустриальные IDE прямо сталкиваются с этим и рекомендуют увеличивать лимиты; JetBrains отмечает, что при исчерпании watch‑лимита IDE вынуждена деградировать к рекурсивному сканированию. citeturn7search21  
- **macOS/kqueue**: Apple‑документация указывает, что нужно открывать file descriptor для каждого файла, который вы хотите наблюдать через kqueue; это плохо масштабируется. citeturn7search14  
  Документация fswatch также подчёркивает, что kqueue требует FD на каждый наблюдаемый файл и «плохо масштабируется», упираясь в лимит открытых файлов. citeturn7search20  
- **fsnotify (кроссплатформенный слой)**: документация пакета фиксирует, что на macOS/BSD он использует kqueue, на Linux — inotify. citeturn7search4

Вывод: для non‑git Project Mode разумнее сразу проектировать **гибрид**:

1) быстрое обнаружение изменений (события + дешёвый stat‑путь),  
2) подтверждение (content hash) только для кандидатов,  
3) периодическая «верификация» (скан по расписанию или при открытии панели), чтобы компенсировать пропуски событий и race‑conditions.

### Формат diff и алгоритмы: не переизобретать без нужды

Если вы генерируете diff сами (non‑git baseline), то следует понимать два слоя:

- алгоритм построения минимального edit script / LCS‑подобного diff; классическая работа Майерса формализует O(ND) алгоритм и является де‑факто основой многих реализаций. citeturn9search0turn9search9  
- формат представления diff; unified format — общепринятый обменный формат (GNU diffutils описывает его как более компактную вариацию context format, выбор — `-u`). citeturn9search11turn9search15

Практическая рекомендация: если на Git‑ветке вы используете `git diff`, то для non‑git лучше либо (а) повторять unified формат и вашу модель hunk/line, либо (б) показывать «IDE‑diff» как отдельную структуру, но максимально близко к семантике unified (заголовок файла, hunks с диапазонами строк).

### Надёжная запись и restore: атомарная замена файла

Для операции restore и для обычного сохранения в редакторе критичны: целостность и предсказуемость «что увидят другие процессы».

На POSIX‑системах стандартным паттерном является запись во временный файл на том же файловом разделе и атомарный `rename()` поверх целевого пути: man‑страница подчёркивает, что если `newpath` существует, он будет **атомарно заменён**, без промежутка «файл отсутствует». citeturn8search0  
Это полезно и для restore, и для «write under sudo»: вы минимизируете окно, где файл частично записан или повреждён.

## Права доступа и безопасность: обычный пользователь, sudo, sudoedit‑подход

### Почему «запуск редактора под root» — плохая база

Документация `sudo` прямо указывает, что многие команды (включая большинство редакторов) позволяют shell escapes, и после `sudo vi` последующие команды из этого редактора фактически обходят модель ограничений. citeturn6view0  
Из этого вытекает best practice: **давать привилегии на минимально необходимую операцию**, а не на весь интерактивный UI‑процесс.

### Эталон: sudoedit как модель «привилегии только на установку результата»

Секция `sudo -e/--edit` описывает, что:

1) создаются временные копии редактируемых файлов с владельцем «invoking user»;  
2) редактор запускается для редактирования временных файлов;  
3) если изменены, временные файлы копируются обратно. citeturn4view0

Там же перечислены ограничения, защищающие от атак через symlink и writable‑directories (например, «symlinks may not be edited», «files located in a directory writable by invoking user may not be edited» и т.п.). citeturn5view0turn6view0

Для TUI IDE это почти готовая спецификация «как делать безопасное сохранение привилегированного файла»:

- **Редактор всегда работает как обычный пользователь** (буферы, diff, history, state).  
- При попытке сохранить файл без прав — редактор предлагает “Write with sudo” и выполняет лишь «копирование результата» в привилегированное место, повторяя ограничения sudoedit (особенно запреты на symlink‑тропы и writable‑директории). citeturn6view0

### Практические правила учёта пользователя при sudo

`sudo` документирует переменные окружения `SUDO_UID`, `SUDO_GID`, `SUDO_USER`, `SUDO_HOME`. citeturn6view0  
`sudpors(5)` также отмечает, что при запуске sudo под root наличие `SUDO_USER` используется политикой для определения «actual user» в некоторых сценариях. citeturn4view1

Отсюда нормы для state/snapshot:

- В **обычном режиме** state хранить в `$XDG_STATE_HOME/<app>` (или дефолт `$HOME/.local/state/<app>`). citeturn2search3  
- В **режиме, когда процесс всё же root** (например, пользователь действительно сделал `sudo qedit …`), определять «реального пользователя» лучше по `SUDO_UID/SUDO_GID` (как числам) и/или `SUDO_USER`, и:
  - писать state в директорию реального пользователя,
  - выставлять владельца и права так, чтобы user мог читать/чистить эти данные (например, каталоги 0700). citeturn6view0turn2search3

Ключевой риск, который нужно прямо учитывать в дизайне: если вы запускаете Git‑команды из root‑процесса в пользовательском репозитории, Git может отказать из‑за safe.directory/ownership protection. citeturn2search21turn1search5  
Поэтому: Git‑интеграцию лучше исполнять «от имени пользователя» (в идеале — сам редактор не root).

## Организация интерфейса в терминале: паттерны компоновки и workflow

Ниже — набор практик из терминальных редакторов (Vim/Helix) и из редакторных git‑панелей (Zed), адаптированных к вашему «Local Changes Panel».

image_group{"layout":"carousel","aspect_ratio":"16:9","query":["Helix editor pickers preview screenshot","Vimdiff terminal split view screenshot","lazygit interface screenshot changed files diff","Zed editor Project Diff Uncommitted Changes screenshot"],"num_per_query":1}

### Базовые паттерны layout для TUI‑редакторов

**Паттерн «picker + preview / overlay» (Helix‑стиль).**  
Helix описывает pickers как интерактивные окна выбора (file picker, global search и т.д.), со своим keymap. citeturn0search7turn0search15turn0search31  
Для панели изменений это означает: список файлов (левая колонка или верхний список) + предпросмотр diff рядом/рядом с ним, быстрые клавиши, закрытие по Esc.

**Паттерн «split diff view» (Vimdiff‑стиль).**  
Vim документация по diff режиму показывает, что diff‑сценарий естественно раскладывается в несколько окон, где различия подсвечены и можно перемещать изменения. citeturn8search3turn8search31  
Даже если вы не делаете «двухоконный merge», паттерн «изменения рядом с кодом» хорошо поддерживает когнитивную проверку.

**Паттерн «multibuffer project diff» (Zed‑стиль).**  
Zed описывает Project Diff как представление «всех изменений Git» в виде редактируемых excerpts, с возможностью stage/unstage hunks и file. citeturn12search1turn12search6  
Даже если вы пока не реализуете staging, стоит взять UX‑механику: «collapsible hunks», «collapse/expand all», и внимание к производительности на больших diff‑массивах. citeturn12search4turn12search11

### Диаграммы рабочих потоков

**Состояния файла в редакторе** (рекомендуемая минимальная модель):

```text
           (baseline) ---------------------> (changed vs baseline)
               |                                     |
               | open/read                             | restore
               v                                     v
        (buffer clean) ---- edit ----> (buffer dirty) -----> (buffer == baseline)
               |                       /    ^
               | external change      /     | undo restore (до закрытия панели)
               v                     v      |
        (disk changed externally)  (conflict: buffer vs disk vs baseline)
```

Опора на «трёхсторонний конфликт» обусловлена тем, что Git‑мир естественно трёхслоен (HEAD/index/worktree), а в non‑git мире аналог — baseline/disk/buffer. citeturn11search3turn1search1

**Слои изменений в Git** (почему staged/unstaged надо показывать отдельно):

```text
HEAD (последний коммит)
  |  diff --cached  (staged changes)
INDEX (staging area)
  |  diff            (unstaged changes)
WORKING TREE (файлы на диске)
```

Это напрямую следует из определения «трёх деревьев» в Pro Git и из описания `git diff` как сравнения между working/index/commit trees. citeturn11search3turn11search0

### UX‑детали для удобства и скорости

Для TUI‑секций (в духе Vim/Helix) обычно работает связка принципов:

- **Стабильная навигация и предсказуемость клавиш**: `j/k`, `Enter`, `Esc/q`, плюс подсказка‑легенда снизу (как в концепте). fileciteturn0file1  
- **Понятная сигнатура опасных действий**: «restore» должен быть визуально помечен как destructive (и иметь undo). Концепция уже вводит undo restore буфер, что существенно снижает риск «случайного r». fileciteturn0file0  
- **Фильтрация/ограничение объёма**: иначе панель может стать источником лагов. В экосистеме Zed зафиксирован реальный класс проблем — «слишком много untracked файлов приводит к зависанию при построении diff‑мультибуфера». citeturn12search8  
- **Игнорирование “шумных” директорий по умолчанию** в non‑git (node_modules, target, dist и т.п.), либо настройка exclude‑паттернов; иначе и сканирование, и diff‑подготовка станут непредсказуемыми.

Для логики команд и помощи полезно ориентироваться на CLI‑гайдлайны: ясные сообщения об ошибках, аккуратное использование терминального пространства, уважение к привычным паттернам Unix‑инструментов. citeturn10search2

## Рекомендации по реализации и базовый стандарт поведения по сценариям

### Рекомендуемая «осевая» спецификация: что считать baseline и что означает restore

Ключевая рекомендация: **разделить понятия “показать изменения” и “выполнить restore” по источнику baseline** и сделать это единообразно во всех контекстах.

- В Git‑репозитории baseline логично определять относительно `HEAD` и `index` (двухслойно). citeturn11search3turn1search1  
- Вне Git baseline должен быть либо «эпохой проекта», либо «эпохой файла», управляемой пользователем (reset baseline), а не вечным «первым открытием когда‑то». Это снижает накопление «вечных изменений» в state. citeturn2search3  
- Под sudo best practice — «редактор как user + привилегия только на запись результата», по образцу sudoedit. citeturn4view0turn6view0

### Таблица: baseline и обработка файлов в разных контекстах (проект/git/права)

Таблица ниже задаёт «baseline‑норму» для вашего редактора: что считается исходной точкой, как вычислять diff, что делает restore, и какие guardrails нужны. citeturn3search1turn1search1turn6view0turn2search3

| Контекст файла | Определение baseline | Как получать список изменённых | Что показывает diff | Что делает restore | Обязательные guardrails |
|---|---|---|---|---|---|
| В проекте, tracked Git, обычные права | Двухслойно: `HEAD→index` и `index→worktree` | `git status --porcelain=v2 -z` | Два diff слоя (или агрегированный с явной меткой) | (а) discard unstaged = restore worktree из index; (б) discard all = restore и index и worktree из HEAD | Явно показывать staged/unstaged; подтверждение для “discard all” при наличии staged |
| В проекте, untracked Git | baseline отсутствует в Git | `git status --porcelain=v2` | Для предпросмотра: diff «∅ → файл» (как add) | По умолчанию: переместить в “trash”/state‑quarantine или удалить с подтверждением | Защита от массового удаления; ограничения по количеству |
| В проекте, Git, файл удалён | baseline = `HEAD` (и/или index) | `git status --porcelain=v2` | Показать удаление | Restore = вернуть файл из `HEAD` (и возможно восстановить staged‑state отдельно) | Учитывать частично staged сценарии |
| В проекте, non‑git | baseline = project epoch (реком.) или file epoch | Скан + ignore + (опц.) watcher | unified‑подобный diff baseline↔disk; при открытом буфере — disk↔buffer | Restore = атомарно вернуть baseline‑контент | Команда “Reset baseline”; квоты на state; исключения директорий |
| Вне проекта, обычный пользователь | baseline = file epoch snapshot | Отслеживать только этот файл | baseline↔disk | Restore = вернуть snapshot | Понятный индикатор “external file mode” |
| Привилегированный файл (например /etc/hosts), рекомендованный режим | baseline = snapshot; запись через sudoedit‑подобный helper | Отслеживать этот файл | baseline↔buffer | Restore: (а) вернуть baseline в буфер; (б) запись результата — через helper | Повторить ограничения sudoedit против symlink/writable‑dirs; логировать/сообщать ошибки записи |
| Привилегированный файл, редактор запущен как root (не рекоменд.) | baseline = snapshot в state user (не root) | этот файл | baseline↔disk | restore + запись на диск | Chown state‑файлов на SUDO_UID; избегать git‑операций от root (safe.directory) |

### Технические рекомендации «как лучше реализовать» поверх предложенного плана

Ниже — рекомендации, которые дополняют ваш текущий план пакета `internal/changes` и делают поведение устойчивее в реальных проектах. fileciteturn0file1

**Git‑часть**

- Перейти с «простого парсинга» к `git status --porcelain=v2 -z` как основному протоколу обмена; он расширяем и рассчитан на парсеры. citeturn3search1turn3search5  
- Явно хранить в `ChangedFile` поле «есть staged?» и «есть unstaged?», а не только `Modified/Added/Deleted`, иначе UI не сможет корректно подписывать restore‑семантику. citeturn1search1turn11search3  
- Для restore использовать современную семантику `git restore` (worktree/staged/source) вместо `git checkout HEAD -- file`, чтобы поведение было декларативным и проще объяснялось. citeturn1search1turn11search25

**Non‑git часть**

- Если цель — «видеть все изменения AI в проекте», то минимальный компромисс: при открытии проекта построить **манифест** (пути + stat + быстрый хэш для малых файлов), но с жёсткой ignore‑политикой и лимитами размера/количества. Противоположный «lazy‑только‑открытые» режим оставить как опцию “lightweight”. citeturn7search0turn7search21turn2search3  
- Хранить baseline в `$XDG_STATE_HOME` и уважать переменную, а не только `~/.local/state`, чтобы вписаться в системные ожидания. citeturn2search3  
- Объединить «undo restore» и baseline‑хранение через контент‑адресуемую схему (например, blob‑store по SHA‑256): это снижает риск больших in‑memory буферов и упрощает rollback‑транзакции.

**События и “external modifications”**

- Проверка только по `mtime` (как в плане) недостаточно надёжна на сетевых ФС и при некоторых инструментах записи; лучше хранить `(inode, size, mtime)` и при расхождении — подтверждать контент‑хэшем для открытых файлов. Ограничения inotify (нерекурсивность) и общие проблемы наблюдения деревьев надо принять как норму и компенсировать периодическим сканом. citeturn7search0turn7search12turn7search4

**UI‑часть**

- Встроить “Collapse/Expand all hunks” как обязательный инструмент, иначе большие diff‑файлы обрушат читаемость. Это же направление видно в changelog‑деталях Zed (в мультибуферах добавляют collapse/expand и оптимизации рендера больших diff). citeturn12search4turn12search11  
- Для «опасных» действий (restore all, delete untracked) использовать двухшаговую механику: требуется явное подтверждение (или удержание клавиши/команды), плюс всегда доступно undo restore хотя бы до закрытия панели (как у вас задумано). fileciteturn0file0

### Минимальный baseline для первой версии (pragmatic baseline)

Если трактовать «baseline» как контракт, который лучше не менять после релиза, то минимально безопасный «первый стандарт» может быть таким:

- Git‑репозиторий:  
  - список файлов = `git status --porcelain=v2 -z`,  
  - показываем две группы: **Staged** и **Unstaged** (даже если без staging‑операций),  
  - restore по умолчанию = «discard unstaged» (восстановить worktree из index),  
  - отдельная команда/клавиша = «discard all (staged+unstaged)» с явным предупреждением. citeturn3search1turn1search1turn11search25  
- Non‑git проект:  
  - baseline = «эпоха проекта» (создаётся при открытии workspace; сбрасывается командой),  
  - детекция = скан с ignore‑паттернами + периодическая верификация,  
  - restore = атомарная запись через temp+rename. citeturn8search0turn7search0  
- Привилегированные файлы:  
  - «правильный путь» = sudoedit‑подобный механизм сохранения,  
  - state всегда остаётся на стороне user (`XDG_STATE_HOME`),  
  - root‑запуск поддерживать как legacy‑режим, но документировать как нежелательный из‑за рисков ownership/safe.directory. citeturn4view0turn6view0turn2search21