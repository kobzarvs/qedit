# Local Changes — обновлённая концепция (GPT)

## Кратко
Панель Local Changes показывает **все локальные изменения в проекте** — независимо от источника (пользователь, AI-агенты, скрипты). Слева список изменённых файлов, справа — diff выбранного файла. Есть безопасный restore с undo.

## Почему это нужно
AI-инструменты могут изменить десятки файлов без явного участия пользователя. Нужен быстрый ответ на три вопроса:
- что изменилось?
- где именно?
- как быстро откатить?

## UX (минимальная версия)

```
┌─ Local Changes ─────────┬─────────────────────────────────────────┐
│ 3 changed files         │ editor.go                               │
│                         │ - 245 │ data := e.content()             │
│ ● editor.go             │ + 245 │ data := joinLines(e.lines)       │
│   config.go             │ + 246 │ // validation added              │
│   types.go              │                                        
└─────────────────────────┴─────────────────────────────────────────┘
 j/k: nav | Enter: open | r: restore | u: undo restore | Esc: close
```

- **Слева**: список файлов с изменениями.
- **Справа**: diff выбранного файла.
- **Restore**: откатить файл к baseline/HEAD.
- **Undo restore**: вернуть изменения после отката (1 уровень).

## Принципы
1. **Git-first**: если есть Git — базой считается HEAD.
2. **Неразрушающий restore**: перед восстановлением сохраняем текущую версию в буфер undo.
3. **Lazy snapshot** вне Git: baseline сохраняется при первом открытии файла.
4. **Открытый буфер важнее диска**: diff для текущего файла строится по in-memory содержимому.
5. **Минимум шума**: панель только по команде `:changes` (без авто-попапов).

## Что считается «исходным состоянием»

### Git-репозиторий
- **Baseline = HEAD** (последний коммит)
- Список изменений: `git status --porcelain -z`
- Diff: строится по `HEAD` vs текущее содержимое
  - для активного буфера берём in-memory содержимое
  - для остальных файлов читаем содержимое с диска
- Restore:
  - tracked: `git checkout -- <file>`
  - untracked/added: удалить файл (с undo-буфером)

### Вне Git
- **Baseline = snapshot при первом открытии**
- Snapshot хранится в `~/.local/state/qedit/projects/<hash>/baseline/`
- В списке изменений участвуют **только** файлы, для которых есть baseline
- Diff строится baseline vs текущее содержимое

### Single File Mode
- Условие: файл вне проекта и/или нет git-репо для пути
- Snapshot в `~/.local/state/qedit/files/<hash>`
- Панель показывает только этот файл

## Безопасность restore
- Перед restore делаем in-memory копию (undo buffer)
- 1 уровень undo на файл
- Буфер живёт только до закрытия панели или следующего restore того же файла

## Что сознательно откладывается
- Авто-обновление панели каждые N секунд
- fsnotify и popups на внешние изменения
- Группировка по папкам
- Отличение AI-изменений от ручных

## Открытые вопросы (решаем в процессе реализации)
- Нужно ли учитывать staged изменения (скорее да, в общем списке)?
- Как именно обновлять baseline вне Git (по команде “accept” или вручную)?
- Хочется ли отдельную команду `:changes refresh`?
