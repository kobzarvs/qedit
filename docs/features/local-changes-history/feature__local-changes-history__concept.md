# Local Changes History — Концепция

## Проблема

Современные AI-инструменты (Claude Code, Cursor, Aider, Codex) постоянно вносят изменения в файлы проекта.
Разработчик может отвлечься на минуту, а AI уже изменил 10 файлов.

**Вопросы, которые возникают:**
- Какие файлы изменились?
- Что именно было изменено?
- Как откатить изменения, если что-то пошло не так?

---

## Решение: Local Changes Panel

Редактор показывает **все изменённые файлы в проекте** — не важно,
кто их изменил: сам пользователь, AI-агент или внешний скрипт.

### Что видит пользователь

```
┌─ Local Changes [Git] ───┬──────────────────────────────────┐
│ 3 changed files         │ editor.go                        │
│                         │                                  │
│ ● editor.go    [S][M]   │   245 │ if path == "" {          │
│   config.go       [M]   │ - 246 │     data := e.content()  │
│   newfile.go      [?]   │ + 246 │     data := joinLines()  │
│                         │ + 247 │     // validation added  │
│                         │   248 │ }                        │
│                         │                                  │
└─────────────────────────┴──────────────────────────────────┘
 ↑↓: nav | r: restore | u: undo | Ctrl+Shift+R: restore all
```

**Индикаторы в Git-режиме:**
- `[S]` — staged (готово к коммиту)
- `[M]` — modified (unstaged)
- `[?]` — untracked (новый файл)

**Заголовок** — индикатор режима: `[Git]`, `[Project]` или `[File]`
**Слева** — список изменённых файлов
**Справа** — diff выбранного файла (красное = удалено, зелёное = добавлено)
**Внизу** — toast-сообщения ("Restored. Press 'u' to undo")

### Действия пользователя

| Действие             | Что происходит                                         |
|----------------------|--------------------------------------------------------|
| Открыть панель       | Команда `:changes`                                     |
| Навигация по файлам  | `↑/↓` или `j/k`                                        |
| Скролл diff          | `Shift+↑/↓` или `J/K`, `Tab` для переключения фокуса   |
| Страница вверх/вниз  | `PgUp/PgDn`                                            |
| В начало/конец       | `Home/End`                                             |
| Откатить файл        | `r` — файл вернётся к исходному состоянию              |
| Откатить всё         | `Ctrl+Shift+R` — **с подтверждением** "Restore all?"   |
| Отменить откат       | `u` — вернуть изменения (показывается toast-подсказка) |

### Защита от случайного отката

Откат — это потенциально опасная операция. Можно случайно потерять нужные изменения.

**Решение: перед откатом сохраняем текущую версию**

```
Пользователь нажимает 'r' (откат файла)
          ↓
Редактор сохраняет текущую версию во временный буфер
          ↓
Файл откатывается к исходному состоянию
          ↓
Если ошибся — нажимаешь 'u' и изменения возвращаются
```

Это работает как обычный Undo, но для операции отката целого файла.

**Важно:** буфер отката хранится только до закрытия панели или до следующего отката того же файла

---

## Как определяется "исходное состояние"

### В Git-репозитории (90% случаев)

**Исходное состояние = последний коммит (git HEAD)**

Это самый простой и надёжный способ:
- Git уже отслеживает все изменения
- Не нужно ничего дополнительно хранить
- Работает мгновенно даже на больших проектах
- "Откатить" = вернуть файл к состоянию последнего коммита

### Вне Git-репозитория

**Исходное состояние = манифест проекта при запуске**

Когда редактор работает в папке без Git:
1. При **запуске** редактор создаёт манифест: список файлов с их размером, временем и хэшем
2. При открытии `:changes` — сравнивает текущее состояние с манифестом
3. Видит **ВСЕ** изменившиеся файлы, включая те, что изменил AI в фоне

**Исключения (всегда игнорируются):**
- `node_modules/`, `vendor/`, `.git/`, `target/`, `dist/`, `build/`
- Файлы из `.gitignore` (если есть)
- Бинарные файлы, файлы >1MB

Файл из исключённой папки → обрабатывается как **Single File Mode**

---

## Особый случай: редактирование одиночных файлов

### Пример: `sudo qedit /etc/hosts`

Когда редактируем файл вне проекта (системный файл, конфиг, etc.):

| Аспект   | Ситуация                               |
|----------|----------------------------------------|
| Проект   | Нет проекта — это одиночный файл       |
| Git      | Нет Git-репозитория                    |
| Права    | Файл требует sudo                      |
| Snapshot | Куда сохранять? `~` при sudo = `/root` |

**Решение: для одиночных файлов — упрощённый режим**

1. **Определяем "одиночный файл":**
   - Файл находится вне текущей директории (CWD)
   - ИЛИ редактор запущен с абсолютным путём к файлу

2. **Что делаем:**
   - Snapshot сохраняем в: `~/.local/state/qedit/files/<hash>`
   - При sudo: определяем home через `$SUDO_USER` (см. ниже)
   - Local Changes панель показывает только этот один файл

3. **Ограничения:**
   - Нет отслеживания "всего проекта" — проекта нет
   - Только один файл в панели изменений

### Определение $HOME при sudo

```
sudo qedit /etc/hosts
     ↓
$HOME = /root (плохо — потеряем snapshot при выходе из sudo)
     ↓
Решение: проверяем $SUDO_USER + user.Lookup()
     ↓
Получаем реальный home: /Users/username (macOS) или /home/username (Linux)
```

Используем системный вызов `user.Lookup()` вместо хардкода пути — работает на macOS и Linux.

---

## Сценарии использования

### Сценарий 1: Работа с AI-агентом

```
1. Открыт редактор с проектом
2. Claude Code вносит изменения в 5 файлов
3. Пользователь открывает :changes
4. Видит все 5 файлов и что именно изменилось
5. Один файл испорчен — нажимает 'r' для отката
6. Остальные изменения оставляет
```

### Сценарий 2: Внешние изменения

```
1. Файл открыт в редакторе
2. Кто-то (AI или скрипт) изменил этот файл на диске
3. Редактор показывает предупреждение:
   "Файл изменён извне. Перезагрузить? [y/n]"
4. Пользователь решает: принять изменения или оставить свою версию
```

### Сценарий 3: "Что я натворил?"

```
1. Пользователь редактировал файлы
2. Хочет посмотреть все свои изменения перед коммитом
3. Открывает :changes
4. Видит полную картину всех изменений в проекте
```

### Сценарий 4: Случайный откат

```
1. Пользователь в панели :changes
2. Хотел откатить config.go, но случайно нажал 'r' на editor.go
3. Упс! Важные изменения в editor.go исчезли
4. Нажимает 'u' — изменения возвращаются
5. Теперь аккуратно выбирает config.go и откатывает его
```

### Сценарий 5: Редактирование системного файла

```
1. sudo qedit /etc/hosts
2. Добавили новую запись
3. Открываем :changes — видим только /etc/hosts
4. Diff показывает добавленную строку
5. Если ошиблись — 'r' откатывает к исходному состоянию
6. Snapshot сохранён в ~/.local/state/qedit/ (домашняя папка пользователя, не root)
```

---

## Ключевые принципы

1. **Проект = текущая папка**
   Редактор отслеживает изменения во всей папке, откуда он запущен

2. **Всё в одном месте**
   Не важно, кто изменил файл — пользователь, AI или внешний скрипт. Все изменения видны в одной панели

3. **Простой откат с защитой**
   Одна клавиша `r` — откат. Одна клавиша `u` — отмена отката. Массовый откат `R` требует подтверждения

4. **Git-first**
   В Git-репозиториях используем Git напрямую. Режимы: `[Git]` (все изменения + staged/unstaged), `[Project]` (манифест), `[File]` (одиночный файл)

5. **Без прерывающих попапов**
   Внешние изменения показываются в статус-баре `[Disk Changed]`, а не назойливыми диалогами. Панель обновляется автоматически

6. **Неразрушающий подход**
   Даже откат можно отменить — текущая версия сохраняется перед откатом

---

## Решённые вопросы (по результатам ревью)

1. **Автоматическое обновление панели** → **Да**
   Панель обновляется автоматически (fsnotify или polling 1-2 сек). Это критично для наблюдения за AI.

2. **Уведомления о внешних изменениях** → **Статус-бар, не попапы**
   Попапы раздражают при работе с AI (10 правок подряд). Используем `[Disk Changed]` в статус-баре.

3. **Группировка изменений** → **Плоский список**
   Для < 20 файлов плоский список удобнее. Группировка по папкам — в будущем.

4. **Выделять изменения от AI** → **Нет**
   Технически невозможно определить "автора" изменения на уровне файловой системы. Просто показываем "Modified".
